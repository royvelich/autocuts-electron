<link rel="import" href="../../bower_components/polymer/polymer-element.html">
<link rel="import" href="../../bower_components/polymer/lib/utils/render-status.html">
<link rel="import" href="../../bower_components/iron-resizable-behavior/iron-resizable-behavior.html">
<link rel="import" href="../mesh-provider/mesh-provider.html">
<dom-module id="mesh-view">
  <template>
    <style>
      :host {
        width: 100%;
        height: 100%;
      }

      canvas {
        display: block;
      }

      .container {
        overflow: hidden;
        width: 100%;
        height: 100%;
        position: relative;
      }

      .canvas-title {
        margin: 0px;
        padding: 0px;
        position: absolute;
        top: 20px;
        left: 20px;
        font-size: 30px;
        color: white;
      }
    </style>
    <div class="container">
      <div class="canvas-title">
        [[title]]
      </div>
    </div>
  </template>
  <script>
    class MeshView extends Polymer.mixinBehaviors([Polymer.IronResizableBehavior], Polymer.Element) {
      static get is() {
        return "mesh-view";
      }

      static get properties() {
        return {
          meshProvider: {
            type: Object,
            value: function () {
              return new MeshProvider();
            },
            observer: '_meshProviderChanged'
          },
          title: {
            type: String
          },
          backgroundColor: {
            type: String,
            value: function () {
              return "rgb(0, 0, 0)";
            },
            observer: '_backgroundColorChanged'
          },
          showWireframe: {
            type: Boolean,
            value: function () {
              return false;
            },
            observer: '_showWireframeChanged'
          }
        }
      }

      connectedCallback() {
        super.connectedCallback();
        this.addEventListener('iron-resize', e => this._resizeScene());
        Polymer.RenderStatus.beforeNextRender(this, function () {
          this._resizeScene()
          this._connectScene();
          this._renderScene();
        });
      }

      ready() {
        this.THREE = require('three');
        this.meshViewResizeSubscriptionToken = require('pubsub-js').subscribe('mesh-view.resize', () => this._resizeScene());
        this._initialize();
        super.ready();
      }

      _showWireframeChanged(showWireframe) {
        this.scene.remove(this.meshWireframe);
        if (showWireframe) {
          this.scene.add(this.meshWireframe);
        }
      }

      _rebuildScene() {
        // let meshProviderVertices = this.meshProvider.getVertices();
        // let meshProviderFaces = this.meshProvider.getFaces();
        // let vertices = [];

        // meshProviderFaces.forEach(function (face) {
        //   let v0 = meshProviderVertices[face[0]];
        //   let v1 = meshProviderVertices[face[1]];
        //   let v2 = meshProviderVertices[face[2]];
        //   vertices.push(v0.x, v0.y, v0.z);
        //   vertices.push(v1.x, v1.y, v1.z);
        //   vertices.push(v2.x, v2.y, v2.z);
        // });

        this.material = new this.THREE.MeshBasicMaterial({
          color: 0xff0000
        });

        this.wireframeMaterial = new this.THREE.MeshBasicMaterial({
          color: 0x000000,
          wireframe: true,
        });

        this.geometry = new this.THREE.BufferGeometry();
        this.geometry.addAttribute('position', new this.THREE.BufferAttribute(new Float32Array(this.meshProvider.getBufferedVertices()),
          3));

        this.mesh = new this.THREE.Mesh(this.geometry, this.material);
        this.meshWireframe = new this.THREE.Mesh(this.geometry, this.wireframeMaterial)

        this.scene.add(this.mesh);

        if (this.showWireframe) {
          this.scene.add(this.meshWireframe);
        }
      }

      _meshProviderChanged(meshProvider) {
        if (this.scheduledAnimationFrameId) {
          cancelAnimationFrame(this.scheduledAnimationFrameId);
        }

        this._renderScene();
      }

      _backgroundColorChanged(color) {
        let THREE = require('three');
        this.renderer.setClearColor(new THREE.Color(color), 1.0);
      }

      _clearSceneSubtree(object) {
        while (object.children.length > 0) {
          this._clearSceneSubtree(object.children[0])
          object.remove(object.children[0]);
        }

        if (object.geometry) {
          object.geometry.dispose()
        }

        if (object.material) {
          object.material.dispose()
        }

        if (object.texture) {
          object.texture.dispose()
        }
      }

      _initialize() {
        this._createCamera()
        this._createRenderer();
        this._createScene();
        this._createOrbitControl();
      }

      _createCamera() {
        let THREE = require('three');
        this.camera = new THREE.PerspectiveCamera(45, 0, 0.1, 10000);
        this.camera.position.z = 2;
      }

      _createRenderer() {
        let THREE = require('three');
        this.renderer = new THREE.WebGLRenderer({
          antialias: true
        });
        this.renderer.setPixelRatio(window.devicePixelRatio);
      }

      _createScene() {
        let THREE = require('three');
        this.scene = new THREE.Scene();
      }

      _createOrbitControl() {
        let THREE = require('three');
        let OrbitControls = require('three-orbit-controls')(THREE);
        this.controls = new OrbitControls(this.camera, this.renderer.domElement);
        this.controls.enableDamping = true;
        this.controls.dampingFactor = 0.25;
        this.controls.screenSpacePanning = false;
        this.controls.enableKeys = false;
        this.controls.minDistance = 0;
        this.controls.maxDistance = 1000;
        this.controls.maxPolarAngle = 2 * Math.PI;
      }

      _resizeScene() {
        let THREE = require('three');
        this.camera.aspect = this.offsetWidth / (this.offsetHeight);
        this.camera.updateProjectionMatrix();
        this.renderer.setSize(this.offsetWidth, this.offsetHeight);
      }

      _renderScene() {
        this.scheduledAnimationFrameId = requestAnimationFrame(() => this._renderScene());
        this._rebuildScene();
        this.renderer.render(this.scene, this.camera);
        this._clearSceneSubtree(this.scene);
      }

      _connectScene() {
        this.root.querySelector('.container').appendChild(this.renderer.domElement);
      }
    }
    customElements.define(MeshView.is, MeshView);
  </script>
</dom-module>