<link rel="import" href="../../bower_components/polymer/polymer-element.html">
<link rel="import" href="../../bower_components/polymer/lib/utils/render-status.html">
<link rel="import" href="../../bower_components/iron-resizable-behavior/iron-resizable-behavior.html">
<link rel="import" href="../mesh-provider/mesh-provider.html">
<link rel="import" href="./statsjs-import.html">
<dom-module id="mesh-view">
  <template>
    <style>
      :host {
        width: 100%;
        height: 100%;
      }

      canvas {
        display: block;
      }

      .container {
        overflow: hidden;
        width: 100%;
        height: 100%;
        position: relative;
      }

      .canvas-title {
        margin: 0px;
        padding: 0px;
        position: absolute;
        top: 20px;
        left: 20px;
        font-size: 30px;
        color: white;
      }
    </style>
    <div class="container">
      <div class="canvas-title">[[title]]</div>
    </div>
  </template>
  <script>
    class MeshView extends Polymer.mixinBehaviors([Polymer.IronResizableBehavior], Polymer.Element) {
      static get is() {
        return "mesh-view";
      }

      static get properties() {
        return {
          meshProvider: {
            type: Object,
            value: function () {
              return new MeshProvider();
            },
            observer: '_meshProviderChanged'
          },
          title: {
            type: String
          },
          backgroundColor: {
            type: String,
            value: function () {
              return "rgb(0, 0, 0)";
            },
            observer: '_backgroundColorChanged'
          },
          showWireframe: {
            type: Boolean,
            value: function () {
              return false;
            },
            observer: '_showWireframeChanged'
          },
          meshInteraction: {
            type: String,
            value: function () {
              return 'rotate';
            },
            observer: '_meshInteractionChanged'
          },
        }
      }

      connectedCallback() {
        super.connectedCallback();
        this.addEventListener('iron-resize', e => this._resizeScene());
        Polymer.RenderStatus.beforeNextRender(this, function () {
          this._resizeScene()
          this._connectScene();
          this._renderScene();
        });
      }

      ready() {
        this.THREE = require('three');
        this.meshViewResizeSubscriptionToken = require('pubsub-js').subscribe('mesh-view.resize', () => this._resizeScene());
        this._initialize();
        super.ready();
      }

      _showWireframeChanged(showWireframe) {
        if (this.meshWireframe) {
          this.meshWireframe.visible = showWireframe;
        }
      }

      _meshProviderChanged(meshProvider) {
        let THREE = require('three');
        this._clearSceneSubtree(this.scene);

        this.material = new THREE.MeshBasicMaterial({
          color: 0xff0000
        });

        this.wireframeMaterial = new THREE.MeshBasicMaterial({
          color: 0x000000,
          wireframe: true
        });

        this.geometry = new THREE.BufferGeometry();
        this.geometry.addAttribute('position', new THREE.BufferAttribute(new Float32Array(this.meshProvider.bufferedVertices),
          3));

        this.mesh = new THREE.Mesh(this.geometry, this.material);
        this.meshWireframe = new this.THREE.Mesh(this.geometry, this.wireframeMaterial)

        this.scene.add(this.mesh);
        this.scene.add(this.meshWireframe);

        this.raycaster = new THREE.Raycaster();

        this.lineGeometry = new THREE.BufferGeometry();
        this.lineGeometry.addAttribute('position', new THREE.BufferAttribute(new Float32Array(4 * 3), 3));
        this.lineMaterial = new THREE.LineBasicMaterial({
          color: 0xffffff,
          linewidth: 2,
          transparent: true
        });
        this.line = new THREE.Line(this.lineGeometry, this.lineMaterial);
        this.scene.add(this.line);
      }

      _backgroundColorChanged(color) {
        let THREE = require('three');
        this.renderer.setClearColor(new THREE.Color(color), 1.0);
      }

      _meshInteractionChanged(meshInteraction) {
        this.controls.enableRotate = (meshInteraction == 'rotate');
      }

      _clearSceneSubtree(object) {
        while (object.children.length > 0) {
          this._clearSceneSubtree(object.children[0])
          object.remove(object.children[0]);
        }

        if (object.geometry) {
          object.geometry.dispose()
        }

        if (object.material) {
          object.material.dispose()
        }

        if (object.texture) {
          object.texture.dispose()
        }
      }

      _initialize() {
        let THREE = require('three');
        this._createCamera()
        this._createRenderer();
        this._createScene();
        this._createOrbitControl();
        this._mousePosition = new THREE.Vector2();
        this._mouseDown = false;
        this._faceIndex = NaN;
        this._faceDrag = false;
      }

      _createCamera() {
        let THREE = require('three');
        this.camera = new THREE.PerspectiveCamera(45, 0, 0.1, 10000);
        this.camera.position.z = 2;
      }

      _createRenderer() {
        let THREE = require('three');
        this.renderer = new THREE.WebGLRenderer({
          antialias: true
        });
        this.renderer.setPixelRatio(window.devicePixelRatio);
      }

      _createScene() {
        let THREE = require('three');
        this.scene = new THREE.Scene();
      }

      _createOrbitControl() {
        let THREE = require('three');
        let OrbitControls = require('three-orbit-controls')(THREE);
        this.controls = new OrbitControls(this.camera, this.renderer.domElement);
        this.controls.enableDamping = true;
        this.controls.dampingFactor = 0.25;
        this.controls.screenSpacePanning = false;
        this.controls.enableKeys = false;
        this.controls.minDistance = 0;
        this.controls.maxDistance = 1000;
        this.controls.maxPolarAngle = 2 * Math.PI;
        this.controls.enableRotate = false;
      }

      _resizeScene() {
        let THREE = require('three');
        this.camera.aspect = this.offsetWidth / (this.offsetHeight);
        this.camera.updateProjectionMatrix();
        this.renderer.setSize(this.offsetWidth, this.offsetHeight);
      }

      _renderScene() {
        this.stats.begin();

        // Update mesh vertices to match the current state of the mesh provider
        let positions = this.geometry.attributes.position.array;
        for (let i = 0; i < positions.length; i++) {
          positions[i] = this.meshProvider.bufferedVertices[i];
        }

        if (this.meshInteraction === 'faces' && !this._faceDrag) {
          // Test if the mouse cursor hovers above a mesh face
          this.raycaster.setFromCamera(this._mousePosition, this.camera);
          let intersects = this.raycaster.intersectObject(this.mesh);
          if (intersects.length > 0) {
            var intersect = intersects[0];
            var face = intersect.face;
            var linePosition = this.line.geometry.attributes.position;
            var meshPosition = this.mesh.geometry.attributes.position;
            linePosition.copyAt(0, meshPosition, face.a);
            linePosition.copyAt(1, meshPosition, face.b);
            linePosition.copyAt(2, meshPosition, face.c);
            linePosition.copyAt(3, meshPosition, face.a);
            this.line.geometry.applyMatrix(this.mesh.matrix);
            this._faceIndex = Math.round(intersect.faceIndex / 3);
            this.line.visible = true;
          } else {
            this.line.visible = false;
          }
        }

        this.geometry.attributes.position.needsUpdate = true;

        this.renderer.render(this.scene, this.camera);

        this.stats.end();

        this.scheduledAnimationFrameId = requestAnimationFrame(() => this._renderScene());
      }

      _connectScene() {
        this.renderer.domElement.onmousedown = this._mouseDownHandler.bind(this)
        this.renderer.domElement.onmousemove = this._mouseMoveHandler.bind(this)
        this.renderer.domElement.onmouseup = this._mouseUpHandler.bind(this)
        this.root.querySelector('.container').appendChild(this.renderer.domElement);
        this.stats = new Stats();
        this.stats.showPanel(1);
        this.stats.dom.style.position = 'absolute';
        this.stats.dom.style.top = '';
        this.stats.dom.style.bottom = '0px';
        this.root.querySelector('.container').appendChild(this.stats.dom);
      }

      _mouseDownHandler(e) {
        this._mouseDown = true;

        switch (this.meshInteraction) {
          case 'faces':
            if (!isNaN(this._faceIndex)) {
              require('pubsub-js').publish('mesh-view-face-down', {
                faceIndex: this._faceIndex
              });
            }
            break;
        }
      }

      _mouseMoveHandler(e) {
        event.preventDefault();
        let bounding = this.renderer.domElement.getBoundingClientRect();
        this._mousePosition.x = (event.offsetX / bounding.width) * 2 - 1;
        this._mousePosition.y = -(event.offsetY / bounding.height) * 2 + 1;

        if (this._mouseDown) {
          switch (this.meshInteraction) {
            case 'faces':
              if (!isNaN(this._faceIndex)) {
                if (!this._faceDrag) {
                  this._faceDrag = true;
                }

                require('pubsub-js').publish('mesh-view-face-drag', {
                  faceIndex: this._faceIndex,
                  offsetX: e.movementX / 30,
                  offsetY: e.movementY / 30
                });
              }
              break;
          }
        }
      }

      _mouseUpHandler(e) {
        this._mouseDown = false;

        switch (this.meshInteraction) {
          case 'faces':
            if (this._faceDrag) {
              this._faceDrag = false;
              if (this._faceIndex !== NaN) {
                require('pubsub-js').publish('mesh-view-face-up', {
                  faceIndex: this._faceIndex
                });
              }
            }
            break;
        }
      }
    }
    customElements.define(MeshView.is, MeshView);
  </script>
</dom-module>